<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer</title>
    <!-- If you're reading this, you're either him â€” or me. -->
    <style>
        :root {
            --primary-bg: #f5f5f5;
            --secondary-bg: #ffffff;
            --primary-text: #333333;
            --secondary-text: #666666;
            --accent-color: #4a6fa5;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* You won't find it in the DOM. But it finds you. */
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            background-color: var(--primary-bg);
            color: var(--primary-text);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background-color: var(--secondary-bg);
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .app-title {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--accent-color);
        }
        
        .theme-selector {
            display: flex;
            gap: 1rem;
        }
        
        .theme-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            background-color: var(--secondary-bg);
            color: var(--primary-text);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .theme-btn:hover {
            background-color: var(--accent-color);
            color: white;
        }
        
        .theme-btn.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        main {
            flex: 1;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .theme-container {
            width: 100%;
            max-width: 1200px;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            box-shadow: 0 4px 6px var(--shadow-color);
            overflow: hidden;
        }
        
        .theme-content {
            height: 600px;
            width: 100%;
            border: none;
        }
        
        .welcome-message {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .welcome-message h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        
        .welcome-message p {
            font-size: 1.1rem;
            color: var(--secondary-text);
            max-width: 800px;
            margin: 0 auto;
        }
        
        .status-bar {
            background-color: var(--secondary-bg);
            padding: 0.5rem 2rem;
            font-size: 0.9rem;
            color: var(--secondary-text);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .status-indicator.active {
            background-color: #4caf50;
            box-shadow: 0 0 5px #4caf50;
        }
        
        .status-indicator.inactive {
            background-color: #f44336;
            box-shadow: 0 0 5px #f44336;
        }
        
        .hidden {
            display: none !important;
        }
        
        #screen-block {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            z-index: 1000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            text-align: center;
            padding: 2rem;
        }
        
        #screen-block .document-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        
        .startup-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-bg);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }
        
        .startup-screen h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }
        
        .startup-screen p {
            font-size: 1.5rem;
            color: var(--secondary-text);
            margin-bottom: 2rem;
        }
        
        .startup-screen .loader {
            width: 50px;
            height: 50px;
            border: 5px solid var(--border-color);
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- SDCast would never approve of this gradient. That's why I used it. -->
    <div class="startup-screen" id="startup-screen">
        <h1>BLACKOUT</h1>
        <p>Loading system components...</p>
        <div class="loader"></div>
    </div>

    <!-- This markup is haunted. Don't blame the CSS. -->
    <header>
        <div class="app-title">Document Viewer</div>
        <div class="theme-selector">
            <button class="theme-btn active" data-theme="document">Document</button>
            <button class="theme-btn" data-theme="terminal">Terminal</button>
            <button class="theme-btn" data-theme="editor">Editor</button>
        </div>
    </header>
    
    <main>
        <div class="welcome-message">
            <h1>Document Viewer</h1>
            <p>A simple application for viewing and editing documents in a distraction-free environment.</p>
        </div>
        
        <div class="theme-container">
            <iframe src="document.html" class="theme-content" id="theme-content"></iframe>
        </div>
    </main>
    
    <div class="status-bar">
        <div>
            <span class="status-indicator inactive" id="extension-status"></span>
            <span id="status-text">Extension not detected</span>
        </div>
        <div>
            <span id="version-text">v2.0.0</span>
        </div>
    </div>
    
    <div id="screen-block">
        <div class="document-icon">ðŸ“„</div>
        <h2>Document Viewer</h2>
        <p>Currently viewing a document. Please wait...</p>
    </div>
    
    <script>
        /* Uncomment at your own risk. */
        document.addEventListener('DOMContentLoaded', function() {
            // Elements
            const themeButtons = document.querySelectorAll('.theme-btn');
            const themeContent = document.getElementById('theme-content');
            const extensionStatus = document.getElementById('extension-status');
            const statusText = document.getElementById('status-text');
            const screenBlock = document.getElementById('screen-block');
            const startupScreen = document.getElementById('startup-screen');
            
            // State
            let extensionDetected = false;
            let bypassMode = false;
            let secretCode = '';
            let secretTimeout;
            const secretUnlock = 'lights-out';
            
            /* I buried something in the source. Look harder. */
            
            // Theme pages mapping
            const themes = {
                document: 'document.html',
                terminal: 'terminal.html',
                editor: 'editor.html'
            };
            
            // Startup sequence - check for GoGuardian
            setTimeout(() => {
                checkForGoGuardian();
                
                // After a delay, either show the app or block it
                setTimeout(() => {
                    startupScreen.style.display = 'none';
                    
                    if (extensionDetected || bypassMode) {
                        // Continue to app
                    } else {
                        // Block application
                        document.body.innerHTML = `
                            <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; text-align: center; padding: 2rem;">
                                <h1 style="color: #f44336; font-size: 2rem; margin-bottom: 1rem;">Application Unavailable</h1>
                                <p style="font-size: 1.2rem; max-width: 600px; margin: 0 auto 2rem auto;">This application requires the GoGuardian extension to function properly. Please ensure the extension is installed and try again.</p>
                                <button id="retry-btn" style="padding: 0.75rem 1.5rem; background-color: #4a6fa5; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem;">Retry</button>
                            </div>
                        `;
                        
                        // Add retry functionality
                        document.getElementById('retry-btn').addEventListener('click', () => {
                            window.location.reload();
                        });
                    }
                }, 2000);
            }, 1500);
            
            // Check for GoGuardian extension
            function checkForGoGuardian() {
                // Method 1: Check for extension-related elements
                const ggElements = document.querySelectorAll(
                    '[id*="gg-"], [class*="gg-"], ' +
                    '[id*="goguardian-"], [class*="goguardian-"], ' +
                    '[id*="teacher-"], [class*="teacher-"]'
                );
                
                // Method 2: Check for scripts
                const scripts = document.querySelectorAll('script');
                let scriptDetected = false;
                
                scripts.forEach(script => {
                    const src = script.src || '';
                    if (src.includes('goguardian') || src.includes('teacher')) {
                        scriptDetected = true;
                    }
                });
                
                // Method 3: Check for extension-related network requests
                // Note: This is a more advanced technique and less reliable in basic detection
                
                // Set extension status based on findings
                extensionDetected = ggElements.length > 0 || scriptDetected;
                
                if (extensionDetected) {
                    extensionStatus.classList.remove('inactive');
                    extensionStatus.classList.add('active');
                    statusText.textContent = 'GoGuardian detected';
                } else {
                    extensionStatus.classList.remove('active');
                    extensionStatus.classList.add('inactive');
                    statusText.textContent = 'Extension not detected';
                }
            }
            
            // Theme switching
            themeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Only allow switching if extension is detected or bypass mode is active
                    if (extensionDetected || bypassMode) {
                        const theme = button.getAttribute('data-theme');
                        
                        // Update active button
                        themeButtons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                        
                        // Update iframe content
                        themeContent.src = themes[theme];
                    } else {
                        alert('Function unavailable. Extension required.');
                    }
                });
            });
            
            // Listen for secret code
            document.addEventListener('keydown', (e) => {
                // Clear the timeout if it exists
                if (secretTimeout) {
                    clearTimeout(secretTimeout);
                }
                
                // Add the key to the code
                secretCode += e.key.toLowerCase();
                
                /* There's a div here that only shows at 3:33AM. */
                
                // Check if the code is too long, keep only the last N characters
                if (secretCode.length > secretUnlock.length * 2) {
                    secretCode = secretCode.substring(secretCode.length - secretUnlock.length * 2);
                }
                
                // Check if the code contains the unlock sequence
                if (secretCode.includes(secretUnlock)) {
                    // Activate bypass mode
                    bypassMode = true;
                    
                    // Show confirmation
                    console.log('Bypass mode activated through secret code');
                    
                    // Reload the page to apply bypass
                    window.location.reload();
                }
                
                // Set a timeout to clear the code after a delay
                secretTimeout = setTimeout(() => {
                    secretCode = '';
                }, 2000);
            });
            
            // Monitor detection handling
            function setupMonitoringDetection() {
                // Monitor mouse movements to reduce false positives
                let mouseMovementCount = 0;
                let lastMouseX = 0;
                let lastMouseY = 0;
                
                document.addEventListener('mousemove', (e) => {
                    // Only increment if movement is significant
                    const dx = Math.abs(e.clientX - lastMouseX);
                    const dy = Math.abs(e.clientY - lastMouseY);
                    
                    if (dx > 5 || dy > 5) {
                        mouseMovementCount++;
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    }
                });
                
                // Reset counter periodically to avoid false positives
                setInterval(() => {
                    mouseMovementCount = 0;
                }, 500);
                
                // Add more sophisticated detection...
            }
            
            // Initialize monitoring detection
            setupMonitoringDetection();
        });
        /* This comment wasn't in the commit logs. */

        // Add enhanced monitoring detection functions
        function setupEnhancedMonitoring() {
            let detectionCount = 0;
            let lastDetectionTime = 0;
            let mouseMovements = [];
            let similarMovementCount = 0;
            
            // Network Request Monitoring
            function monitorNetworkRequests() {
                // Intercept fetch requests
                const originalFetch = window.fetch;
                window.fetch = function(resource, init) {
                    if (typeof resource === 'string' && (
                        resource.includes('goguardian') || 
                        resource.includes('monitor') || 
                        resource.includes('teacher') ||
                        resource.includes('securly') ||
                        resource.includes('classroom') && resource.includes('google') ||
                        resource.includes('screen') && resource.includes('capture')
                    )) {
                        possibleMonitoringDetected();
                        detectionCount++;
                        throw new Error('Monitoring request blocked');
                    }
                    return originalFetch.apply(this, arguments);
                };

                // Intercept XMLHttpRequest
                const originalXHR = window.XMLHttpRequest;
                window.XMLHttpRequest = function() {
                    const xhr = new originalXHR();
                    const originalOpen = xhr.open;
                    xhr.open = function(method, url) {
                        if (typeof url === 'string' && (
                            url.includes('goguardian') || 
                            url.includes('monitor') || 
                            url.includes('teacher') ||
                            url.includes('securly') ||
                            url.includes('classroom') && url.includes('google') ||
                            url.includes('screen') && url.includes('capture')
                        )) {
                            possibleMonitoringDetected();
                            detectionCount++;
                            throw new Error('Monitoring request blocked');
                        }
                        return originalOpen.apply(this, arguments);
                    };
                    return xhr;
                };
            }

            // DOM manipulation protection
            function protectDOM() {
                // Monitor suspicious DOM changes
                const domObserver = new MutationObserver(mutations => {
                    let suspiciousChanges = 0;
                    
                    mutations.forEach(mutation => {
                        // Check for added nodes with monitoring-related attributes
                        if (mutation.addedNodes) {
                            mutation.addedNodes.forEach(node => {
                                if (node.nodeType === 1) { // Element node
                                    // Check attributes
                                    if (node.hasAttributes()) {
                                        for (let i = 0; i < node.attributes.length; i++) {
                                            const attr = node.attributes[i];
                                            const value = attr.value.toLowerCase();
                                            if (value.includes('goguardian') || 
                                                value.includes('monitor') || 
                                                value.includes('teacher') ||
                                                value.includes('screen') && value.includes('capture') ||
                                                value.includes('securly')) {
                                                suspiciousChanges++;
                                            }
                                        }
                                    }
                                    
                                    // Check for invisible elements that may be monitoring
                                    if (node.style && (
                                        node.style.opacity === '0' ||
                                        node.style.visibility === 'hidden' ||
                                        node.style.display === 'none'
                                    )) {
                                        // Check if it has monitoring-related attributes or classes
                                        if (node.id && (
                                            node.id.includes('monitor') ||
                                            node.id.includes('guard') ||
                                            node.id.includes('teacher') ||
                                            node.id.includes('screen') ||
                                            node.id.includes('capture')
                                        )) {
                                            suspiciousChanges++;
                                        }
                                    }
                                }
                            });
                        }
                        
                        // Check for attribute changes
                        if (mutation.type === 'attributes') {
                            const target = mutation.target;
                            const attrName = mutation.attributeName;
                            const attrValue = target.getAttribute(attrName);
                            
                            if (attrValue && attrValue.toLowerCase && (
                                attrValue.toLowerCase().includes('goguardian') ||
                                attrValue.toLowerCase().includes('monitor') ||
                                attrValue.toLowerCase().includes('teacher') ||
                                attrValue.toLowerCase().includes('securly')
                            )) {
                                suspiciousChanges++;
                            }
                        }
                    });
                    
                    if (suspiciousChanges >= 2) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                });
                
                domObserver.observe(document.documentElement, {
                    childList: true,
                    attributes: true,
                    characterData: true,
                    subtree: true
                });
            }

            // WebSocket monitoring
            function monitorWebSockets() {
                const originalWebSocket = window.WebSocket;
                window.WebSocket = function(url, protocols) {
                    if (typeof url === 'string' && (
                        url.includes('goguardian') || 
                        url.includes('monitor') || 
                        url.includes('teacher') ||
                        url.includes('securly') ||
                        url.includes('classroom') && url.includes('google'))) {
                        possibleMonitoringDetected();
                        detectionCount++;
                        throw new Error('Monitoring WebSocket blocked');
                    }
                    return new originalWebSocket(url, protocols);
                };
            }

            // Detect monitoring browser extensions
            function detectMonitoringExtensions() {
                // Check for specific extension IDs related to monitoring
                const knownExtensionIds = [
                    'haldlgldplgnggkjaafhelgiaglafanh', // GoGuardian
                    'kjnellgnmkpcefnbmcmabjioaolliinm', // Securly
                    'jaoebcikabjppaclpgbodmmnfjihdngk', // Lightspeed
                    'honjcnefekfnompampcpmcdadibmjhlk'  // Bark
                ];
                
                if (window.chrome && chrome.runtime && chrome.runtime.connect) {
                    knownExtensionIds.forEach(id => {
                        try {
                            chrome.runtime.connect(id);
                            // If connection succeeds, extension is present
                            possibleMonitoringDetected();
                            detectionCount++;
                        } catch (e) {
                            // Extension not found, which is good
                        }
                    });
                }
                
                // Look for extension-specific CSS
                setTimeout(() => {
                    const allElements = document.querySelectorAll('*');
                    let monitoringClasses = 0;
                    
                    allElements.forEach(el => {
                        const classes = el.className;
                        if (typeof classes === 'string' && (
                            classes.includes('goguardian') ||
                            classes.includes('securly') ||
                            classes.includes('lightspeed') ||
                            classes.includes('monitor') && classes.includes('extension')
                        )) {
                            monitoringClasses++;
                        }
                    });
                    
                    if (monitoringClasses > 0) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                }, 2000);
            }

            // Canvas fingerprinting detection
            function detectCanvasFingerprinting() {
                const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
                const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
                
                let canvasReadCount = 0;
                const canvasReadThreshold = 5;
                const canvasReadResetInterval = 10000; // 10 seconds
                
                // Reset the counter periodically
                setInterval(() => {
                    canvasReadCount = 0;
                }, canvasReadResetInterval);
                
                // Monitor canvas data extraction (common in fingerprinting)
                HTMLCanvasElement.prototype.toDataURL = function() {
                    canvasReadCount++;
                    if (canvasReadCount > canvasReadThreshold) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                    return originalToDataURL.apply(this, arguments);
                };
                
                CanvasRenderingContext2D.prototype.getImageData = function() {
                    canvasReadCount++;
                    if (canvasReadCount > canvasReadThreshold) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                    return originalGetImageData.apply(this, arguments);
                };
            }

            // Mouse Movement Analysis
            function setupMouseMonitoring() {
                let lastMouseX = 0;
                let lastMouseY = 0;
                
                // Mouse movement monitoring
                window.addEventListener('mousemove', function(e) {
                    // Store movement vectors
                    if (lastMouseX !== 0 && lastMouseY !== 0) {
                        const dx = e.clientX - lastMouseX;
                        const dy = e.clientY - lastMouseY;
                        mouseMovements.push({dx, dy});
                        
                        // Keep only the last 20 movements
                        if (mouseMovements.length > 20) {
                            mouseMovements.shift();
                        }
                        
                        // Analyze movement patterns
                        if (mouseMovements.length >= 10) {
                            analyzeMouseMovements();
                        }
                    }
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
            }

            function analyzeMouseMovements() {
                // Check for perfectly straight lines or regular patterns
                let straightLineCount = 0;
                let perfectAngles = 0;
                
                for (let i = 1; i < mouseMovements.length; i++) {
                    const prev = mouseMovements[i - 1];
                    const curr = mouseMovements[i];
                    
                    // Perfectly horizontal or vertical movements
                    if ((curr.dx === 0 && prev.dx === 0) || (curr.dy === 0 && prev.dy === 0)) {
                        straightLineCount++;
                    }
                    
                    // Calculate angle between movements
                    const angle1 = Math.atan2(prev.dy, prev.dx);
                    const angle2 = Math.atan2(curr.dy, curr.dx);
                    const angleDiff = Math.abs(angle2 - angle1);
                    
                    // Check for identical angle changes (highly suspicious)
                    if (i > 1) {
                        const prev2 = mouseMovements[i - 2];
                        const angle0 = Math.atan2(prev2.dy, prev2.dx);
                        const angleDiff1 = Math.abs(angle1 - angle0);
                        
                        if (Math.abs(angleDiff - angleDiff1) < 0.01) {
                            perfectAngles++;
                        }
                    }
                }
                
                if (straightLineCount > 5 || perfectAngles > 3) {
                    similarMovementCount++;
                    if (similarMovementCount > 2) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                } else {
                    // Reset count if no suspicious movement detected
                    similarMovementCount = Math.max(0, similarMovementCount - 1);
                }
            }

            // Initialize all enhanced monitoring features
            function initializeEnhancedMonitoring() {
                monitorNetworkRequests();
                protectDOM();
                monitorWebSockets();
                detectMonitoringExtensions();
                detectCanvasFingerprinting();
                setupMouseMonitoring();
                
                // Set up periodic checks
                setInterval(function() {
                    // Skip if we already detected monitoring
                    if (monitoringDetected) return;
                    
                    // Check for suspicious elements
                    const suspiciousElements = document.querySelectorAll(
                        '[class*="capture"], [class*="record"], ' + 
                        '[class*="screen"], [id*="screen"], ' + 
                        '[class*="monitor"], [id*="monitor"], ' + 
                        '[class*="goguardian"], [id*="goguardian"]'
                    );
                    
                    // Check for monitoring iframes
                    const monitoringIframes = document.querySelectorAll('iframe:not(#browser-frame)');
                    
                    if (suspiciousElements.length > 2 || monitoringIframes.length > 0) {
                        possibleMonitoringDetected();
                        detectionCount++;
                    }
                }, 3000);
            }

            // Call to setup all enhanced monitoring
            initializeEnhancedMonitoring();
            
            // Make functions and state available globally
            window.monitoringState = {
                isDetected: () => monitoringDetected,
                isBypassed: () => bypassMonitoring,
                toggleBypass: () => toggleBypassMode()
            };
            
            // Override the existing possibleMonitoringDetected function
            window.possibleMonitoringDetected = function() {
                const currentTime = Date.now();
                // If this is a new detection (not within the last second)
                if (currentTime - lastDetectionTime > 1000) {
                    detectionCount++;
                    lastDetectionTime = currentTime;
                    
                    // If we've had multiple detections, consider monitoring detected
                    if (detectionCount > 3 && !monitoringDetected) {
                        monitoringDetected = true;
                        updateStatus();
                        
                        if (stealthMode && !bypassMonitoring) {
                            activateScreenBlock();
                        }
                    }
                }
            };
        }

        // Initialize enhanced monitoring after page load
        window.addEventListener('load', function() {
            // Setup enhanced monitoring
            setupEnhancedMonitoring();
        });
    </script>
</body>
</html> 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Viewer</title> <!-- Innocuous title -->
    <style>
        :root {
            /* Dark mode colors */
            --primary-bg: #121212;
            --secondary-bg: #1e1e1e;
            --text-color: #d8d8d8;
            --secondary-text: #a0a0a0;
            --accent-color: #4a6fa5;
            --button-color: #2c5282;
            --button-hover: #3a6ea5;
            --error-color: #e53e3e;
            --success-color: #38a169;
            --warning-color: #d69e2e;
            --border-color: #333;
            --input-bg: #2d2d2d;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-family);
            background-color: var(--primary-bg);
            color: var(--text-color);
            line-height: 1.6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        header {
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-logo {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent-color);
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .stealth-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-label {
            font-size: 0.9rem;
            color: var(--secondary-text);
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            border-radius: 24px;
            transition: .4s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: .4s;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--accent-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }
        
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .browser-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border-color);
            margin: 20px;
            border-radius: 8px;
            overflow: hidden;
            background-color: var(--secondary-bg);
        }
        
        .browser-toolbar {
            display: flex;
            padding: 10px;
            gap: 10px;
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
        }
        
        .url-box {
            flex: 1;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 14px;
        }
        
        .url-box:focus {
            outline: none;
            border-color: var(--accent-color);
        }
        
        .go-button {
            padding: 8px 16px;
            background-color: var(--button-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .go-button:hover {
            background-color: var(--button-hover);
        }
        
        .browser-frame-container {
            flex: 1;
            background-color: white;
            position: relative;
        }
        
        .browser-frame {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .status-bar {
            height: 25px;
            background-color: var(--secondary-bg);
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            align-items: center;
            font-size: 12px;
            color: var(--secondary-text);
            border-top: 1px solid var(--border-color);
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        .status-indicator.active {
            background-color: var(--success-color);
            box-shadow: 0 0 4px var(--success-color);
        }
        
        .status-indicator.inactive {
            background-color: var(--error-color);
            box-shadow: 0 0 4px var(--error-color);
        }
        
        .status-indicator.warning {
            background-color: var(--warning-color);
            box-shadow: 0 0 4px var(--warning-color);
        }
        
        .deception-layer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-bg);
            z-index: 10;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px;
            text-align: center;
            font-size: 16px;
        }
        
        .deception-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: var(--accent-color);
        }
        
        .deception-message {
            max-width: 600px;
            margin-bottom: 20px;
        }
        
        /* Hidden message only shows at certain times */
        .hidden-message {
            position: fixed;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: var(--primary-bg);
            transition: bottom 0.3s;
            user-select: none;
            opacity: 0.5;
        }
        
        body:hover .hidden-message {
            bottom: 2px;
        }
    </style>
</head>
<body>
    <div id="deception-layer" class="deception-layer">
        <div class="deception-header">
            <h1>Document Viewer</h1>
        </div>
        <div class="deception-content">
            <div class="document-icon">📄</div>
            <h2>Google Docs Viewer</h2>
            <p>This is a standard document viewer. Nothing to see here.</p>
        </div>
    </div>
    
    <header>
        <div class="header-title">
            <h1 class="visible-title">Document Viewer</h1>
            <h1 class="hidden-title">BLACKOUT</h1>
        </div>
    </header>
    
    <main>
        <div class="container">
            <div class="controls">
                <div class="switch-container">
                    <span class="switch-label">Stealth Mode:</span>
                    <label class="switch">
                        <input type="checkbox" id="stealth-switch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="switch-container">
                    <span class="switch-label">Dark Theme:</span>
                    <label class="switch">
                        <input type="checkbox" id="theme-switch">
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="switch-container">
                    <span class="switch-label">Bypass Mode:</span>
                    <label class="switch">
                        <input type="checkbox" id="bypass-switch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="url-input">
                    <input type="text" id="url-box" placeholder="Enter URL (e.g., example.com)">
                    <button id="go-button">GO</button>
                </div>
                
                <div id="status-display" class="status">
                    Stealth Mode Active: Monitoring protection enabled
                </div>
            </div>
            
            <div class="content">
                <div class="content-header">
                    <span id="current-url">No website loaded</span>
                </div>
                <div class="browser-container">
                    <iframe id="browser-frame" src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-popups"></iframe>
                </div>
            </div>
        </div>
    </main>
    
    <div id="monitoring-notification" class="notification">
        ⚠️ GoGuardian monitoring detected!
    </div>
    
    <footer>
        School Project Template | Educational Use Only
    </footer>
    
    <div class="status-bar">
        <div class="status-item">
            <span class="status-indicator active" id="stealth-status-indicator"></span>
            <span id="stealth-status-text">Stealth: Active</span>
        </div>
        <div class="status-item">
            <span class="status-indicator inactive" id="monitor-status-indicator"></span>
            <span id="monitor-status-text">Monitoring: None</span>
        </div>
        <div class="status-item">
            <span>v2.1.0</span>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const stealthSwitch = document.getElementById('stealth-switch');
            const themeSwitch = document.getElementById('theme-switch');
            const urlBox = document.getElementById('url-box');
            const goButton = document.getElementById('go-button');
            const browserFrame = document.getElementById('browser-frame');
            const statusDisplay = document.getElementById('status-display');
            const currentUrl = document.getElementById('current-url');
            const deceptionLayer = document.getElementById('deception-layer');
            const monitoringNotification = document.getElementById('monitoring-notification');
            const stealthStatusIndicator = document.getElementById('stealth-status-indicator');
            const stealthStatusText = document.getElementById('stealth-status-text');
            const monitorStatusIndicator = document.getElementById('monitor-status-indicator');
            const monitorStatusText = document.getElementById('monitor-status-text');
            
            let stealthMode = true;
            let lastKeyPressTime = 0;
            let monitoringDetected = false;
            let bypassMonitoring = true;
            let secretModeActive = false;
            let extensionDetected = false;
            
            // Set up mode switches
            stealthSwitch.addEventListener('change', function() {
                stealthMode = this.checked;
                updateStatusDisplay();
            });
            
            themeSwitch.addEventListener('change', function() {
                document.body.classList.toggle('dark-mode', this.checked);
            });
            
            const bypassSwitch = document.getElementById('bypass-switch');
            bypassSwitch.addEventListener('change', function() {
                bypassMonitoring = this.checked;
                updateStatusDisplay();
                
                // If monitoring is currently detected, update display immediately
                if (monitoringDetected) {
                    if (bypassMonitoring) {
                        deceptionLayer.style.display = 'none';
                    } else if (stealthMode) {
                        deceptionLayer.style.display = 'flex';
                    }
                }
            });
            
            // Handle URL navigation
            goButton.addEventListener('click', navigateToUrl);
            urlBox.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    navigateToUrl();
                }
            });
            
            function navigateToUrl() {
                let url = urlBox.value.trim();
                
                // Add https:// if not present
                if (url && !url.startsWith('http://') && !url.startsWith('https://')) {
                    url = 'https://' + url;
                }
                
                if (url) {
                    // Update the iframe src
                    browserFrame.src = url;
                    currentUrl.textContent = url;
                }
            }
            
            // Monitor for potential detection
            function setupMonitoringDetection() {
                // Monitor focus/blur events
                let focusTime, blurTime;
                let lastDetectionTime = 0;
                let detectionCount = 0;
                
                window.addEventListener('focus', function() {
                    focusTime = new Date().getTime();
                    
                    // If we're returning to our tab very quickly after a blur,
                    // this might be GoGuardian taking screenshots
                    if (blurTime && (focusTime - blurTime < 200)) {
                        const now = new Date().getTime();
                        if (now - lastDetectionTime < 1000) {
                            detectionCount++;
                            if (detectionCount >= 3) {
                                possibleMonitoringDetected();
                                detectionCount = 0;
                            }
                        } else {
                            detectionCount = 1;
                        }
                        lastDetectionTime = now;
                    }
                });
                
                window.addEventListener('blur', function() {
                    blurTime = new Date().getTime();
                });
                
                // Mouse movement monitoring
                let lastMouseX = 0;
                let lastMouseY = 0;
                let suspiciousMovements = 0;
                let lastMouseTime = 0;
                
                document.addEventListener('mousemove', function(e) {
                    const now = new Date().getTime();
                    if (now - lastMouseTime < 50) return; // Throttle checks
                    lastMouseTime = now;
                    
                    // Detect unnatural mouse movements (straight lines, perfect angles)
                    // that might indicate automated movement
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;
                    
                    // Check for perfectly horizontal or vertical movements
                    // with very precise coordinates
                    if ((Math.abs(dx) < 1 && Math.abs(dy) > 5) || 
                        (Math.abs(dy) < 1 && Math.abs(dx) > 5)) {
                        suspiciousMovements++;
                        if (suspiciousMovements > 5) {
                            possibleMonitoringDetected();
                            suspiciousMovements = 0;
                        }
                    } else {
                        suspiciousMovements = Math.max(0, suspiciousMovements - 1);
                    }
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                // Check for hidden elements periodically
                function checkForHiddenElements() {
                    // Check for elements with screen recording or capture-related classes/IDs
                    const suspiciousElements = document.querySelectorAll(
                        '[class*="capture"], [class*="record"], [id*="capture"], [id*="record"], ' + 
                        '[class*="screen"], [id*="screen"], [class*="monitor"], [id*="monitor"]'
                    );
                    
                    // Check for specific GoGuardian elements
                    const ggElements = document.querySelectorAll(
                        '[id*="gg-"], [class*="gg-"], ' +
                        '[id*="goguardian-"], [class*="goguardian-"], ' +
                        '[id*="teacher-"], [class*="teacher-"]'
                    );
                    
                    // Check for monitoring iframes
                    const monitoringIframes = document.querySelectorAll('iframe:not(#browser-frame)');
                    
                    // Only trigger if we find multiple indicators
                    if ((suspiciousElements.length > 0 && ggElements.length > 0) ||
                        (monitoringIframes.length > 0 && ggElements.length > 0) ||
                        (suspiciousElements.length > 2 && monitoringIframes.length > 0)) {
                        possibleMonitoringDetected();
                    }
                }
                
                // Periodically check for suspicious elements
                setInterval(checkForHiddenElements, 2000);
                
                // Check for GoGuardian extension
                const checkForExtension = setInterval(function() {
                    if (window.chrome && chrome.runtime) {
                        chrome.runtime.sendMessage('goguardian', {}, function(response) {
                            if (chrome.runtime.lastError) {
                                // Extension not found
                                clearInterval(checkForExtension);
                            } else {
                                // Extension found
                                possibleMonitoringDetected();
                            }
                        });
                    }
                }, 5000);
                
                // Check for monitoring scripts
                const scriptObserver = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.addedNodes && mutation.addedNodes.length > 0) {
                            for (let i = 0; i < mutation.addedNodes.length; i++) {
                                const node = mutation.addedNodes[i];
                                if (node.nodeType === 1) { // Element node
                                    // Check for monitoring scripts
                                    if (node.tagName === 'SCRIPT') {
                                        const src = node.src || '';
                                        if (src.includes('goguardian') || 
                                            src.includes('monitor') || 
                                            src.includes('teacher')) {
                                            possibleMonitoringDetected();
                                        }
                                    }
                                }
                            }
                        }
                    });
                });
                
                scriptObserver.observe(document.documentElement, {
                    childList: true,
                    subtree: true
                });
                
                // Secret key combination to toggle stealth mode in emergencies
                // Press 'z' three times quickly
                let zPressCount = 0;
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'z') {
                        const now = new Date().getTime();
                        if (now - lastKeyPressTime < 500) {
                            zPressCount++;
                            if (zPressCount >= 3) {
                                toggleEmergencyMode();
                                zPressCount = 0;
                            }
                        } else {
                            zPressCount = 1;
                        }
                        lastKeyPressTime = now;
                    }
                });
            }
            
            function possibleMonitoringDetected() {
                // Only take action if in stealth mode
                if (!stealthMode) return;
                
                monitoringDetected = true;
                
                // Show notification briefly
                monitoringNotification.style.display = 'block';
                setTimeout(() => {
                    monitoringNotification.style.display = 'none';
                }, 3000);
                
                // Activate deception layer only if bypass mode is not active
                if (!bypassMonitoring) {
                    deceptionLayer.style.display = 'flex';
                    
                    // Auto-hide deception after a period
                    setTimeout(() => {
                        if (Math.random() > 0.3) { // 70% chance to auto-hide
                            deceptionLayer.style.display = 'none';
                            monitoringDetected = false;
                        }
                    }, 5000 + Math.random() * 5000); // Random delay between 5-10 seconds
                }
                
                updateStatusDisplay();
            }
            
            function toggleEmergencyMode() {
                if (deceptionLayer.style.display === 'flex') {
                    deceptionLayer.style.display = 'none';
                    monitoringDetected = false;
                } else {
                    deceptionLayer.style.display = 'flex';
                    monitoringDetected = true;
                }
                updateStatusDisplay();
            }
            
            function updateStatusDisplay() {
                if (stealthMode) {
                    if (monitoringDetected) {
                        statusDisplay.textContent = bypassMonitoring ? 
                            'Monitoring detected, but bypass active - Content remains visible' : 
                            'ALERT: Monitoring detected - Deception active';
                    } else {
                        statusDisplay.textContent = 'Stealth Mode Active: Monitoring protection enabled';
                    }
                } else {
                    statusDisplay.textContent = 'Stealth Mode Disabled: No protection active';
                    deceptionLayer.style.display = 'none';
                }
                
                // Update stealth mode indicator
                if (stealthMode) {
                    stealthStatusIndicator.classList.remove('inactive');
                    stealthStatusIndicator.classList.add('active');
                    stealthStatusText.textContent = 'Stealth: Active';
                } else {
                    stealthStatusIndicator.classList.remove('active');
                    stealthStatusIndicator.classList.add('inactive');
                    stealthStatusText.textContent = 'Stealth: Inactive';
                }
                
                // Update monitoring status indicator
                if (monitoringDetected) {
                    monitorStatusIndicator.classList.remove('inactive');
                    monitorStatusIndicator.classList.add('warning');
                    monitorStatusText.textContent = 'Monitoring: Detected';
                } else {
                    monitorStatusIndicator.classList.remove('warning');
                    monitorStatusIndicator.classList.add('inactive');
                    monitorStatusText.textContent = 'Monitoring: None';
                }
                
                // Make the switches match the state
                stealthSwitch.checked = stealthMode;
                bypassSwitch.checked = bypassMonitoring;
            }
            
            // Additional anti-monitoring measures
            function setupAntiMonitoring() {
                // Prevent screenshotting and screen recording APIs
                document.addEventListener('DOMContentLoaded', function() {
                    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                        navigator.mediaDevices.getDisplayMedia = function() {
                            return new Promise((resolve, reject) => {
                                reject(new Error('getDisplayMedia is disabled'));
                            });
                        };
                    }
                });
                
                // Create content mutation observer to watch for GoGuardian elements
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        if (mutation.addedNodes && mutation.addedNodes.length > 0) {
                            for (let i = 0; i < mutation.addedNodes.length; i++) {
                                const node = mutation.addedNodes[i];
                                if (node.nodeType === 1) { // Element node
                                    // Check if this is potentially a monitoring element
                                    if (node.id && (
                                        node.id.includes('goguardian') || 
                                        node.id.includes('monitor') || 
                                        node.id.includes('screen')
                                    )) {
                                        possibleMonitoringDetected();
                                    }
                                    
                                    if (node.className && (
                                        node.className.includes('goguardian') || 
                                        node.className.includes('monitor') || 
                                        node.className.includes('screen')
                                    )) {
                                        possibleMonitoringDetected();
                                    }
                                }
                            }
                        }
                    });
                });
                
                // Start observing
                observer.observe(document.body, { childList: true, subtree: true });
            }
            
            // Enhanced monitoring detection
            function setupEnhancedMonitoring() {
                // Initialize detection variables
                let detectionCount = 0;
                let lastDetectionTime = 0;
                let mouseMovements = [];
                let similarMovementCount = 0;
                
                // Network Request Monitoring
                function monitorNetworkRequests() {
                    // Intercept fetch requests
                    const originalFetch = window.fetch;
                    window.fetch = function(resource, init) {
                        if (typeof resource === 'string' && (
                            resource.includes('goguardian') || 
                            resource.includes('monitor') || 
                            resource.includes('teacher') ||
                            resource.includes('securly') ||
                            resource.includes('classroom') && resource.includes('google') ||
                            resource.includes('screen') && resource.includes('capture')
                        )) {
                            possibleMonitoringDetected();
                            detectionCount++;
                            throw new Error('Monitoring request blocked');
                        }
                        return originalFetch.apply(this, arguments);
                    };

                    // Intercept XMLHttpRequest
                    const originalXHR = window.XMLHttpRequest;
                    window.XMLHttpRequest = function() {
                        const xhr = new originalXHR();
                        const originalOpen = xhr.open;
                        xhr.open = function(method, url) {
                            if (typeof url === 'string' && (
                                url.includes('goguardian') || 
                                url.includes('monitor') || 
                                url.includes('teacher') ||
                                url.includes('securly') ||
                                url.includes('classroom') && url.includes('google') ||
                                url.includes('screen') && url.includes('capture')
                            )) {
                                possibleMonitoringDetected();
                                detectionCount++;
                                throw new Error('Monitoring request blocked');
                            }
                            return originalOpen.apply(this, arguments);
                        };
                        return xhr;
                    };
                }

                // DOM manipulation protection
                function protectDOM() {
                    // Monitor suspicious DOM changes
                    const domObserver = new MutationObserver(mutations => {
                        let suspiciousChanges = 0;
                        
                        mutations.forEach(mutation => {
                            // Check for added nodes with monitoring-related attributes
                            if (mutation.addedNodes) {
                                mutation.addedNodes.forEach(node => {
                                    if (node.nodeType === 1) { // Element node
                                        // Check attributes
                                        if (node.hasAttributes()) {
                                            for (let i = 0; i < node.attributes.length; i++) {
                                                const attr = node.attributes[i];
                                                const value = attr.value.toLowerCase();
                                                if (value.includes('goguardian') || 
                                                    value.includes('monitor') || 
                                                    value.includes('teacher') ||
                                                    value.includes('screen') && value.includes('capture') ||
                                                    value.includes('securly')) {
                                                    suspiciousChanges++;
                                                }
                                            }
                                        }
                                        
                                        // Check for invisible elements that may be monitoring
                                        if (node.style && (
                                            node.style.opacity === '0' ||
                                            node.style.visibility === 'hidden' ||
                                            node.style.display === 'none'
                                        )) {
                                            // Check if it has monitoring-related attributes or classes
                                            if (node.id && (
                                                node.id.includes('monitor') ||
                                                node.id.includes('guard') ||
                                                node.id.includes('teacher') ||
                                                node.id.includes('screen') ||
                                                node.id.includes('capture')
                                            )) {
                                                suspiciousChanges++;
                                            }
                                        }
                                    }
                                });
                            }
                            
                            // Check for attribute changes
                            if (mutation.type === 'attributes') {
                                const target = mutation.target;
                                const attrName = mutation.attributeName;
                                const attrValue = target.getAttribute(attrName);
                                
                                if (attrValue && attrValue.toLowerCase && (
                                    attrValue.toLowerCase().includes('goguardian') ||
                                    attrValue.toLowerCase().includes('monitor') ||
                                    attrValue.toLowerCase().includes('teacher') ||
                                    attrValue.toLowerCase().includes('securly')
                                )) {
                                    suspiciousChanges++;
                                }
                            }
                        });
                        
                        if (suspiciousChanges >= 2) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                    });
                    
                    domObserver.observe(document.documentElement, {
                        childList: true,
                        attributes: true,
                        characterData: true,
                        subtree: true
                    });
                }

                // WebSocket monitoring
                function monitorWebSockets() {
                    const originalWebSocket = window.WebSocket;
                    window.WebSocket = function(url, protocols) {
                        if (typeof url === 'string' && (
                            url.includes('goguardian') || 
                            url.includes('monitor') || 
                            url.includes('teacher') ||
                            url.includes('securly') ||
                            url.includes('classroom') && url.includes('google'))) {
                            possibleMonitoringDetected();
                            detectionCount++;
                            throw new Error('Monitoring WebSocket blocked');
                        }
                        return new originalWebSocket(url, protocols);
                    };
                }

                // Detect monitoring browser extensions
                function detectMonitoringExtensions() {
                    // Check for specific extension IDs related to monitoring
                    const knownExtensionIds = [
                        'haldlgldplgnggkjaafhelgiaglafanh', // GoGuardian
                        'kjnellgnmkpcefnbmcmabjioaolliinm', // Securly
                        'jaoebcikabjppaclpgbodmmnfjihdngk', // Lightspeed
                        'honjcnefekfnompampcpmcdadibmjhlk'  // Bark
                    ];
                    
                    if (window.chrome && chrome.runtime && chrome.runtime.connect) {
                        knownExtensionIds.forEach(id => {
                            try {
                                chrome.runtime.connect(id);
                                // If connection succeeds, extension is present
                                possibleMonitoringDetected();
                                detectionCount++;
                            } catch (e) {
                                // Extension not found, which is good
                            }
                        });
                    }
                    
                    // Look for extension-specific CSS
                    setTimeout(() => {
                        const allElements = document.querySelectorAll('*');
                        let monitoringClasses = 0;
                        
                        allElements.forEach(el => {
                            const classes = el.className;
                            if (typeof classes === 'string' && (
                                classes.includes('goguardian') ||
                                classes.includes('securly') ||
                                classes.includes('lightspeed') ||
                                classes.includes('monitor') && classes.includes('extension')
                            )) {
                                monitoringClasses++;
                            }
                        });
                        
                        if (monitoringClasses > 0) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                    }, 2000);
                }

                // Canvas fingerprinting detection
                function detectCanvasFingerprinting() {
                    const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
                    const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;
                    
                    let canvasReadCount = 0;
                    const canvasReadThreshold = 5;
                    const canvasReadResetInterval = 10000; // 10 seconds
                    
                    // Reset the counter periodically
                    setInterval(() => {
                        canvasReadCount = 0;
                    }, canvasReadResetInterval);
                    
                    // Monitor canvas data extraction (common in fingerprinting)
                    HTMLCanvasElement.prototype.toDataURL = function() {
                        canvasReadCount++;
                        if (canvasReadCount > canvasReadThreshold) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                        return originalToDataURL.apply(this, arguments);
                    };
                    
                    CanvasRenderingContext2D.prototype.getImageData = function() {
                        canvasReadCount++;
                        if (canvasReadCount > canvasReadThreshold) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                        return originalGetImageData.apply(this, arguments);
                    };
                }

                // Mouse Movement Analysis
                function setupMouseMonitoring() {
                    let lastMouseX = 0;
                    let lastMouseY = 0;
                    
                    // Mouse movement monitoring
                    window.addEventListener('mousemove', function(e) {
                        // Store movement vectors
                        if (lastMouseX !== 0 && lastMouseY !== 0) {
                            const dx = e.clientX - lastMouseX;
                            const dy = e.clientY - lastMouseY;
                            mouseMovements.push({dx, dy});
                            
                            // Keep only the last 20 movements
                            if (mouseMovements.length > 20) {
                                mouseMovements.shift();
                            }
                            
                            // Analyze movement patterns
                            if (mouseMovements.length >= 10) {
                                analyzeMouseMovements();
                            }
                        }
                        
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    });
                }

                function analyzeMouseMovements() {
                    // Check for perfectly straight lines or regular patterns
                    let straightLineCount = 0;
                    let perfectAngles = 0;
                    
                    for (let i = 1; i < mouseMovements.length; i++) {
                        const prev = mouseMovements[i - 1];
                        const curr = mouseMovements[i];
                        
                        // Perfectly horizontal or vertical movements
                        if ((curr.dx === 0 && prev.dx === 0) || (curr.dy === 0 && prev.dy === 0)) {
                            straightLineCount++;
                        }
                        
                        // Calculate angle between movements
                        const angle1 = Math.atan2(prev.dy, prev.dx);
                        const angle2 = Math.atan2(curr.dy, curr.dx);
                        const angleDiff = Math.abs(angle2 - angle1);
                        
                        // Check for identical angle changes (highly suspicious)
                        if (i > 1) {
                            const prev2 = mouseMovements[i - 2];
                            const angle0 = Math.atan2(prev2.dy, prev2.dx);
                            const angleDiff1 = Math.abs(angle1 - angle0);
                            
                            if (Math.abs(angleDiff - angleDiff1) < 0.01) {
                                perfectAngles++;
                            }
                        }
                    }
                    
                    if (straightLineCount > 5 || perfectAngles > 3) {
                        similarMovementCount++;
                        if (similarMovementCount > 2) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                    } else {
                        // Reset count if no suspicious movement detected
                        similarMovementCount = Math.max(0, similarMovementCount - 1);
                    }
                }

                // Initialize all enhanced monitoring features
                function initializeEnhancedMonitoring() {
                    monitorNetworkRequests();
                    protectDOM();
                    monitorWebSockets();
                    detectMonitoringExtensions();
                    detectCanvasFingerprinting();
                    setupMouseMonitoring();
                    
                    // Set up periodic checks
                    setInterval(function() {
                        // Skip if we already detected monitoring
                        if (monitoringDetected) return;
                        
                        // Check for suspicious elements
                        const suspiciousElements = document.querySelectorAll(
                            '[class*="capture"], [class*="record"], ' + 
                            '[class*="screen"], [id*="screen"], ' + 
                            '[class*="monitor"], [id*="monitor"], ' + 
                            '[class*="goguardian"], [id*="goguardian"]'
                        );
                        
                        // Check for monitoring iframes
                        const monitoringIframes = document.querySelectorAll('iframe:not(#browser-frame)');
                        
                        if (suspiciousElements.length > 2 || monitoringIframes.length > 0) {
                            possibleMonitoringDetected();
                            detectionCount++;
                        }
                    }, 3000);
                }

                // Call to setup all enhanced monitoring
                initializeEnhancedMonitoring();
                
                // Make functions and state available globally
                window.monitoringState = {
                    isDetected: () => monitoringDetected,
                    isBypassed: () => bypassMonitoring,
                    toggleBypass: () => {
                        bypassMonitoring = !bypassMonitoring;
                        updateStatusDisplay();
                        
                        // If monitoring is currently detected, update display
                        if (monitoringDetected) {
                            if (bypassMonitoring) {
                                deceptionLayer.style.display = 'none';
                            } else if (stealthMode) {
                                deceptionLayer.style.display = 'flex';
                            }
                        }
                        
                        return bypassMonitoring;
                    }
                };
                
                // Enhanced version of the possibleMonitoringDetected function
                window.possibleMonitoringDetected = function(force = false) {
                    const currentTime = Date.now();
                    
                    // Only register new detections or forced ones
                    if (force || currentTime - lastDetectionTime > 1000) {
                        detectionCount++;
                        lastDetectionTime = currentTime;
                        
                        // If we've had multiple detections, consider monitoring detected
                        if ((detectionCount > 3 || force) && !monitoringDetected) {
                            monitoringDetected = true;
                            updateStatusDisplay();
                            
                            // Only show blocking screen if stealth mode is on and bypass is off
                            if (stealthMode && !bypassMonitoring) {
                                deceptionLayer.style.display = 'flex';
                                
                                // Add some variability to the timing to make detection harder
                                setTimeout(() => {
                                    if (!bypassMonitoring) {
                                        displayWarning("Monitoring Detected", "GoGuardian monitoring detected. Screen blocked.");
                                    }
                                }, 500 + Math.random() * 1000);
                            }
                        }
                    }
                };
            }

            // Call the enhanced monitoring setup
            setupEnhancedMonitoring();
            
            // Initialize
            setupMonitoringDetection();
            setupAntiMonitoring();
            updateStatusDisplay();
        });
    </script>
</body>
</html> 